'\" t
.\"     Title: glib-mkenums
.\"    Author: Owen Taylor
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 08/17/2018
.\"    Manual: User Commands
.\"    Source: GObject
.\"  Language: English
.\"
.TH "GLIB\-MKENUMS" "1" "" "GObject" "User Commands"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
glib-mkenums \- C language enum description generation utility
.SH "SYNOPSIS"
.HP \w'\fBglib\-mkenums\fR\ 'u
\fBglib\-mkenums\fR [OPTION...] [FILE...]
.SH "DESCRIPTION"
.PP
\fBglib\-mkenums\fR
is a small utility that parses C code to extract enum definitions and produces enum descriptions based on text templates specified by the user\&. Typically, you can use this tool to generate enumeration types for the GType type system, for #GObject properties and signal marshalling; additionally, you can use it to generate enumeration values of #GSettings schemas\&.
.PP
\fBglib\-mkenums\fR
takes a list of valid C code files as input\&. The options specified control the text that generated, substituting various keywords enclosed in @ characters in the templates\&.
.SS "Production text substitutions"
.PP
Certain keywords enclosed in @ characters will be substituted in the emitted text\&. For the substitution examples of the keywords below, the following example enum definition is assumed:
.sp .if n \{\ .RS 4 .\} .nf typedef enum { PREFIX_THE_XVALUE = 1 << 3, PREFIX_ANOTHER_VALUE = 1 << 4 } PrefixTheXEnum; .fi .if n \{\ .RE .\}
.PP
@EnumName@
.RS 4
The name of the enum currently being processed, enum names are assumed to be properly namespaced and to use mixed capitalization to separate words (e\&.g\&.
PrefixTheXEnum)\&.
.RE
.PP
@enum_name@
.RS 4
The enum name with words lowercase and word\-separated by underscores (e\&.g\&.
prefix_the_xenum)\&.
.RE
.PP
@ENUMNAME@
.RS 4
The enum name with words uppercase and word\-separated by underscores (e\&.g\&.
PREFIX_THE_XENUM)\&.
.RE
.PP
@ENUMSHORT@
.RS 4
The enum name with words uppercase and word\-separated by underscores, prefix stripped (e\&.g\&.
THE_XENUM)\&.
.RE
.PP
@ENUMPREFIX@
.RS 4
The prefix of the enum name (e\&.g\&.
PREFIX)\&.
.RE
.PP
@VALUENAME@
.RS 4
The enum value name currently being processed with words uppercase and word\-separated by underscores, this is the assumed literal notation of enum values in the C sources (e\&.g\&.
PREFIX_THE_XVALUE)\&.
.RE
.PP
@valuenick@
.RS 4
A nick name for the enum value currently being processed, this is usually generated by stripping common prefix words of all the enum values of the current enum, the words are lowercase and underscores are substituted by a minus (e\&.g\&.
the\-xvalue)\&.
.RE
.PP
@valuenum@
.RS 4
The integer value for the enum value currently being processed\&. If the evaluation fails then
\fBglib\-mkenums\fR
will exit with an error status, but this only happens if
@valuenum@
appears in your value production template\&. (Since: 2\&.26)
.RE
.PP
@type@
.RS 4
This is substituted either by "enum" or "flags", depending on whether the enum value definitions contained bit\-shift operators or not (e\&.g\&. flags)\&.
.RE
.PP
@Type@
.RS 4
The same as
@type@
with the first letter capitalized (e\&.g\&. Flags)\&.
.RE
.PP
@TYPE@
.RS 4
The same as
@type@
with all letters uppercased (e\&.g\&. FLAGS)\&.
.RE
.PP
@filename@
.RS 4
The name of the input file currently being processed (e\&.g\&. foo\&.h)\&.
.RE
.PP
@basename@
.RS 4
The base name of the input file currently being processed (e\&.g\&. foo\&.h)\&. Typically you want to use
@basename@
in place of
@filename@
in your templates, to improve the reproducibility of the build\&. (Since: 2\&.22)
.RE
.SS "Trigraph extensions"
.PP
Some C comments are treated specially in the parsed enum definitions, such comments start out with the trigraph sequence
/*<
and end with the trigraph sequence
>*/\&. Per enum definition, the options "skip" and "flags" can be specified, to indicate this enum definition to be skipped, or for it to be treated as a flags definition, or to specify the common prefix to be stripped from all values to generate value nicknames, respectively\&. The "underscore_name" option can be used to specify the word separation used in the *_get_type() function\&. For instance,
/*< underscore_name=gnome_vfs_uri_hide_options >*/\&.
.PP
Per value definition, the options "skip" and "nick" are supported\&. The former causes the value to be skipped, and the latter can be used to specify the otherwise auto\-generated nickname\&. Examples:
.sp .if n \{\ .RS 4 .\} .nf typedef enum /*< skip >*/ { PREFIX_FOO } PrefixThisEnumWillBeSkipped; typedef enum /*< flags,prefix=PREFIX >*/ { PREFIX_THE_ZEROTH_VALUE, /*< skip >*/ PREFIX_THE_FIRST_VALUE, PREFIX_THE_SECOND_VALUE, PREFIX_THE_THIRD_VALUE, /*< nick=the\-last\-value >*/ } PrefixTheFlagsEnum; .fi .if n \{\ .RE .\}
.SH "OPTIONS"
.PP
\fB\-\-fhead\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
prior to processing input files\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be prepended to the template\*(Aqs
file\-header
section\&.
.RE
.PP
\fB\-\-fprod\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
every time a new input file is being processed\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be appended to the template\*(Aqs
file\-production
section\&.
.RE
.PP
\fB\-\-ftail\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
after all input files have been processed\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be appended to the template\*(Aqs
file\-tail
section\&.
.RE
.PP
\fB\-\-eprod\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
everytime an enum is encountered in the input files\&.
.RE
.PP
\fB\-\-vhead\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
before iterating over the set of values of an enum\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be prepended to the template\*(Aqs
value\-header
section\&.
.RE
.PP
\fB\-\-vprod\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
for every value of an enum\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be appended to the template\*(Aqs
value\-production
section\&.
.RE
.PP
\fB\-\-vtail\fR \fITEXT\fR
.RS 4
Emits
\fITEXT\fR
after iterating over all values of an enum\&.
.sp
You can specify this option multiple times, and the
\fITEXT\fR
will be concatenated\&.
.sp
When used along with a template file,
\fITEXT\fR
will be appended to the template\*(Aqs
value\-tail
section\&.
.RE
.PP
\fB\-\-comments\fR \fITEXT\fR
.RS 4
Template for auto\-generated comments, the default (for C code generations) is
"/* @comment@ */"\&.
.RE
.PP
\fB\-\-template\fR \fIFILE\fR
.RS 4
Read templates from the given file\&. The templates are enclosed in specially\-formatted C comments
.sp .if n \{\ .RS 4 .\} .nf /*** BEGIN section ***/ /*** END section ***/ .fi .if n \{\ .RE .\}
where section may be
file\-header,
file\-production,
file\-tail,
enumeration\-production,
value\-header,
value\-production,
value\-tail
or
comment\&.
.RE
.PP
\fB\-\-identifier\-prefix\fR \fIPREFIX\fR
.RS 4
Indicates what portion of the enum name should be intepreted as the prefix (eg, the "Gtk" in "GtkDirectionType")\&. Normally this will be figured out automatically, but you may need to override the default if your namespace is capitalized oddly\&.
.RE
.PP
\fB\-\-symbol\-prefix\fR \fIPREFIX\fR
.RS 4
Indicates what prefix should be used to correspond to the identifier prefix in related C function names (eg, the "gtk" in "gtk_direction_type_get_type"\&. Equivalently, this is the lowercase version of the prefix component of the enum value names (eg, the "GTK" in "GTK_DIR_UP"\&. The default value is the identifier prefix, converted to lowercase\&.
.RE
.PP
\fB\-\-help\fR
.RS 4
Print brief help and exit\&.
.RE
.PP
\fB\-\-version\fR
.RS 4
Print version and exit\&.
.RE
.PP
\fB\-\-output=FILE\fR
.RS 4
Write output to FILE instead of stdout\&.
.RE
.SH "USING GLIB\-MKENUMS WITH AUTOTOOLS"
.PP
In order to use
\fBglib\-mkenums\fR
in your project when using Autotools as the build system, you will first need to modify your
configure\&.ac
file to ensure you find the appropriate command using
\fBpkg\-config\fR, similarly as to how you discover the compiler and linker flags for GLib\&.
.sp
.if n \{\
.RS 4
.\}
.nf
PKG_PROG_PKG_CONFIG([0\&.28])

PKG_CHECK_VAR([GLIB_MKENUMS], [glib\-2\&.0], [glib_mkenums])
.fi
.if n \{\
.RE
.\}
.PP
In your
Makefile\&.am
file you will typically use rules like these:
.sp
.if n \{\
.RS 4
.\}
.nf
# A list of headers to inspect
project_headers = \e
        project\-foo\&.h \e
        project\-bar\&.h \e
        project\-baz\&.h

enum\-types\&.h: $(project_headers) enum\-types\&.h\&.in
        $(AM_V_GEN)$(GLIB_MKENUMS) \e
                \-\-template=enum\-types\&.h\&.in \e
                \-\-output=$@ \e
                $(project_headers)

enum\-types\&.c: $(project_headers) enum\-types\&.c\&.in enum\-types\&.h
        $(AM_V_GEN)$(GLIB_MKENUMS) \e
                \-\-template=enum\-types\&.c\&.in \e
                \-\-output=$@ \e
                $(project_headers)

BUILT_SOURCES += enum\-types\&.h enum\-types\&.c
CLEANFILES += enum\-types\&.h enum\-types\&.c
EXTRA_DIST += enum\-types\&.h\&.in enum\-types\&.c\&.in
.fi
.if n \{\
.RE
.\}
.PP
In the example above, we have a variable called
project_headers
where we reference all header files we want to inspect for generating enumeration GTypes\&. In the
enum\-types\&.h
rule we use
\fBglib\-mkenums\fR
with a template called
enum\-types\&.h\&.in
in order to generate the header file; a header template file will typically look like this:
.sp
.if n \{\
.RS 4
.\}
.nf
/*** BEGIN file\-header ***/
#pragma once

/* Include the main project header */
#include "project\&.h"

G_BEGIN_DECLS
/*** END file\-header ***/

/*** BEGIN file\-production ***/

/* enumerations from "@filename@" */
/*** END file\-production ***/

/*** BEGIN value\-header ***/
GType @enum_name@_get_type (void) G_GNUC_CONST;
#define @ENUMPREFIX@_TYPE_@ENUMSHORT@ (@enum_name@_get_type ())
/*** END value\-header ***/

/*** BEGIN file\-tail ***/
G_END_DECLS
/*** END file\-tail ***/
.fi
.if n \{\
.RE
.\}
.PP
The
enum\-types\&.c
rule is similar to the rule for the header file, but will use a different
enum\-types\&.c\&.in
template file, similar to this:
.sp
.if n \{\
.RS 4
.\}
.nf
/*** BEGIN file\-header ***/
#include "config\&.h"
#include "enum\-types\&.h"

/*** END file\-header ***/

/*** BEGIN file\-production ***/
/* enumerations from "@filename@" */
/*** END file\-production ***/

/*** BEGIN value\-header ***/
GType
@enum_name@_get_type (void)
{
  static volatile gsize g_@type@_type_id__volatile;

  if (g_once_init_enter (&g_define_type_id__volatile))
    {
      static const G@Type@Value values[] = {
/*** END value\-header ***/

/*** BEGIN value\-production ***/
            { @VALUENAME@, "@VALUENAME@", "@valuenick@" },
/*** END value\-production ***/

/*** BEGIN value\-tail ***/
            { 0, NULL, NULL }
      };

      GType g_@type@_type_id =
        g_@type@_register_static (g_intern_static_string ("@EnumName@"), values);

      g_once_init_leave (&g_@type@_type_id__volatile, g_@type@_type_id);
    }
  return g_@type@_type_id__volatile;
}

/*** END value\-tail ***/
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.PP
\fBglib-genmarshal\fR(1)
